export declare function startLoad(report: (data: any) => void): () => void;
/**
 1. 为什么要用 pageshow 而不是 onload？
传统 onload 的缺陷：
它只在页面首次从网络加载完全部资源（图片、脚本等）时触发。
如果用户点了“后退”按钮回到这个页面，或者浏览器从BFCache（往返缓存）里秒开了这个页面，onload 是不会触发的。
pageshow 的优势：
通吃：不管你是第一次来，还是按后退键回来的，只要页面“展示”出来了，它都会触发。
这能确保你的监控数据覆盖到所有用户看到的场景，不会漏掉那些“后退进入”的访问。
2. 为什么要包一层 requestAnimationFrame (rAF)？
这是为了避让主线程和更精准的时机：

避让：当 pageshow 触发时，浏览器的主线程通常非常忙（正在忙着把页面画出来）。这时候如果直接塞一段 JS 逻辑进去，可能会让页面卡顿一下。
时机：requestAnimationFrame 的意思是：“浏览器大哥，等你把当前这一帧画面画完，准备画下一帧之前的空档，顺手帮我执行一下这个”。
这样做，能确保我们的代码是在页面第一帧渲染完成之后立即执行的，这个时间点更代表“用户真正看见页面”的时刻。
3. performance.now() - event.timeStamp 算的是什么？
event.timeStamp：浏览器触发“显示页面”这个动作的时刻。
performance.now()：代码实际执行（也就是画面渲染完那一刻）的时刻。
相减的结果：渲染延迟。
它在计算：从浏览器决定“要显示页面”，到页面真正“画好并能运行代码”，中间卡了多久。这个数值虽然很小，但能反映出当时页面的渲染压力。
*/
